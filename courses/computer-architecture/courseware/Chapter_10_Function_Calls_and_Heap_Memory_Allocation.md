# Chapter 10: Function Calls and Heap Memory Allocation

## 10-1: Extending Hack VM

### Page 1
Extending Hack VM
John Lapinskas, University of Bristol

### Page 2-6
Our goals for this week
Extend Hack VM to include:
- Function calls.
- Proper compile-time memory allocation.
- Multi-file compilation support for libraries.
- Run-time memory allocation (malloc).

### Page 7-8
How functions should behave
Example: Recursive Fibonacci.
Requirements:
- Jump to function start, return to caller.
- Isolate local variables/arguments.
- Preserve static variables.
- Robust for recursion.

### Page 9-13
Compiling multiple files
- Translate all `.vm` files in a folder to one assembly file.
- Start code by setting SP to 256 and calling `Sys.init`.
- Function names prefixed with filename (e.g., `abc.print`) to prevent clashes.
- Static variables in `abc.vm` map to assembly variables `abc.index`.

### Page 14-15
Jack and the “operating system”
A collection of 8 standard libraries written in Jack (or Hack VM):
`Sys`, `Memory`, `Array`, `String`, `Keyboard`, `Screen`, `Output`, `Math`.

### Page 16-23
Bootstrapping
Writing a compiler for Jack in Jack itself.
Process:
1. Write placeholder Compiler A (in C/VM).
2. Write Compiler B in Jack.
3. Compile Compiler B with Compiler A.
4. Compiler B can now compile itself.

## 10-2: Functions in General

### Page 1
Functions in general
John Lapinskas, University of Bristol

### Page 2-6
A checklist to implement functions
1. Program flow: Jump to start, jump back on return.
2. Memory allocation: Allocate locals/args, free on return.
3. Program state: Save/restore registers and variables.
4. Static variables: Unaffected.

### Page 7
The ubiquity of the stack
The stack is the best structure for this.
Hack VM handles this in software (expensive in assembly), unlike x86/ARM which have hardware support (`CALL`, `RET`, `PUSH`, `POP`).

### Page 8-22
Goal 1: Program flow
- Call: Push return address, jump to function.
- Return: Pop return address, jump to it.
Return address is a label generated by the assembler (e.g., `label11` after the call).

### Page 23-25
Goal 2: Memory allocation
In C/Hack, variable sizes are known at compile time.
Compiler knows how much space is needed for locals/args.

### Page 26-29
Combining goals 2 and 3
Use the stack for call frames.
Call frame structure:
- Arguments (pushed by caller)
- Return address & Saved State (pushed by caller/callee logic)
- Local variables (pushed/reserved by callee)

### Page 30-43
Extended example
Tracing `threemin` and `min` calls.
Shows how the stack grows and shrinks, preserving state (frames) for each call.

### Page 44-46
Terminology
- Call frame: Saved state (return addr, old registers).
- Working stack: Top of stack used for calculations.
- Global stack: The whole thing.
- Heap: Dynamically allocated memory (unrelated to stack).

### Page 47-50
Goal 4: Static variables
 stored in separate `static` segment, unaffected by function calls.

## 10-3: Functions in Hack VM: Syntax and Implementation

### Page 1
Functions in Hack VM: Syntax and implementation
John Lapinskas, University of Bristol

### Page 2-5
Function syntax
- Define: `function functionName nLocals` (initializes `nLocals` local variables to 0).
- Call: `call functionName nArgs` (arguments must be on stack).
- Return: `return` (returns top value of stack).

### Page 7-16
Implementing function calls (`call`)
VM translator generates assembly to:
1. Push return address (label).
2. Push `LCL`, `ARG`, `THIS`, `THAT` (save caller's state).
3. `ARG = SP - nArgs - 5` (reposition ARG to point to first argument).
4. `LCL = SP` (reposition LCL to top of stack).
5. `goto functionName`.
6. `(returnAddressLabel)`: Declare return label.

### Page 17-22
Implementing function definitions (`function`)
1. `(functionName)`: Declare function entry label.
2. Repeat `nLocals` times: `push constant 0`. (Initialize local segment).

### Page 23-33
Implementing function returns (`return`)
1. `FRAME = LCL` (temp variable).
2. `RET = *(FRAME - 5)` (get return address).
3. `*ARG = pop()` (put return value in caller's argument slot).
4. `SP = ARG + 1` (restore SP for caller).
5. `THAT = *(FRAME - 1)`
6. `THIS = *(FRAME - 2)`
7. `ARG = *(FRAME - 3)`
8. `LCL = *(FRAME - 4)`
9. `goto RET`.

### Page 34-36
Initialisation
`Sys.init` calls `Main.main`.
Sets up initial stack and memory segments.

## 10-4: Heap Memory Allocation: malloc and free

### Page 1
Heap memory allocation: malloc and free
John Lapinskas, University of Bristol

### Page 2-3
The two key functions
- `alloc(size)`: Returns base address of segment.
- `deAlloc(base)`: Frees segment.
Heap range: 2048 (0x800) to 16383 (0x3FFF).

### Page 4-9
Attempt 1: Pointer (Basic)
- Maintain `free` pointer (init 2048).
- `alloc(size)`: return `free`, `free += size`.
- `deAlloc(base)`: Do nothing.
- Problem: Memory leak (cannot reuse freed memory).

### Page 10-34
Attempt 2: Linked List (Improved)
- Segments store size.
- Free segments link to each other (next pointer).
- `alloc`: Search list (first-fit), split segment if too big.
- `deAlloc`: Add freed segment to start of list.
- Problem: Fragmentation. Freed adjacent segments are not merged.

### Page 35-58
Attempt 3: Coalescing
- Free list is sorted or we check adjacency.
- `deAlloc`: Check if adjacent memory is free. If so, merge (coalesce).
- Solves fragmentation where adjacent blocks are freed.

### Page 59-77
Fragmentation (External)
Still issues if we alloc/free small blocks randomly.
Solution: Defragmentation (move data). Hard because we can't update pointers held by program (unless using handles/references like Java).
Heuristics: Best-fit vs First-fit.

### Page 78-80
Attempt 4: Bins
- Maintain multiple lists (bins) for different size ranges (e.g. 1-32, 33-64...).
- `alloc`: Go to relevant bin. Fast lookup.
- Used in modern allocators.
